%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,spanish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{spanish}



\setmainfont{DejaVu Serif}
\setsansfont{DejaVu Sans}
\setmonofont{DejaVu Sans Mono}



\usepackage[Bjornstrup]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}


\usepackage[titles]{tocloft}
\cftsetpnumwidth {1.25cm}\cftsetrmarg{1.5cm}
\setlength{\cftchapnumwidth}{0.75cm}
\setlength{\cftsecindent}{\cftchapnumwidth}
\setlength{\cftsecnumwidth}{1.25cm}


\title{Introducción al desarrollo de software}
\date{31 de agosto de 2022}
\release{}
\author{Román Ginés Martínez Ferrández}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{El ordenador: una máquina programable}
\label{\detokenize{software_hardware:el-ordenador-una-maquina-programable}}\label{\detokenize{software_hardware::doc}}
\sphinxAtStartPar
Es bien conocido que el ordenador se compone de dos partes bien diferenciadas: \sphinxstylestrong{software} y \sphinxstylestrong{hardware}.

\sphinxAtStartPar
En este módulo nos vamos a centrar en la parte del software, al final estás cursando un ciclo de programación, pero no podemos obviar el hardware en tanto que lo que vas a aprender a programar es una máquina, es el hardware. Así, voy a empezar por explicarte qué es un ordenador, a nivel de hardware, y lo voy a hacer entrando en la arquitectura de los ordenadores actuales.


\section{Arquitectura von Neumann}
\label{\detokenize{software_hardware:arquitectura-von-neumann}}
\sphinxAtStartPar
Una arquitectura de ordenador es un modelo y una descripción del funcionamiento del mismo. Especial es el papel que juega en esta descripción la forma en la que la Unidad Central de Proceso (CPU, del inglés Central Processing Unit) trabaja internamente y accede a las direcciones de memoria.

\sphinxAtStartPar
La arquiectura von Neumman es una arquitectura de ordenador basada en la descrita en 1945 por el matemático y físico John von Neumann. Esta arquitectura describe un ordenador con tres partes: unidad de procesamiento, memoria principal y unidad de entrada/salida:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.400\linewidth]{{von_neumann}.png}
\caption{Esquema visual con el resumen de la Arquitectura von Neumann}\label{\detokenize{software_hardware:id1}}\end{figure}


\subsection{Unidad de procesamiento}
\label{\detokenize{software_hardware:unidad-de-procesamiento}}
\sphinxAtStartPar
Conocida como \sphinxstylestrong{CPU} (\sphinxstyleemphasis{Centra Procesing Unit}), \sphinxstylestrong{procesador} o \sphinxstylestrong{microprocesador}, se encarga de todas las operaciones y el control del ordenador. Es la CPU lo que, en última instancia, estamos programando.

\sphinxAtStartPar
En la CPU encontramos una \sphinxstylestrong{Unidad Aritmético Lógica}, una serie de \sphinxstylestrong{registros} y una \sphinxstylestrong{Unidad de Control} que te describo brevemente a continuación:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Una \sphinxstylestrong{Unidad Aritmético Lógica}, o \sphinxstylestrong{ALU} del inglés \sphinxstyleemphasis{Arithmetic Logic Unit} que es un circuito digital que realiza operaciones aritméticas (sumas, restas) y operaciones lógicas (IF, AND, OR, NOT, XOR) entre los valores de los argumentos (que pueden ser uno o dos, según el caso).

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.400\linewidth]{{alu_simbolo}.png}
\caption{Típico símbolo esquemático para una ALU: A y B son operandos; R es la salida; F es la entrada de la Unidad de Control; D es un estado de la salida}\label{\detokenize{software_hardware:id2}}\end{figure}


\sphinxstrong{Ver también:}
\nopagebreak


\sphinxAtStartPar
Si sientes curiosidad puedes visitar este sitio web donde encontrarás \sphinxhref{https://hardzone.es/reportajes/que-es/alu/}{detalles de cómo funciona una ALU}%
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxnolinkurl{https://hardzone.es/reportajes/que-es/alu/}
%
\end{footnote}.


\begin{itemize}
\item {} 
\sphinxAtStartPar
Una serie de \sphinxstylestrong{registros} que forman la memoria más rápida de la jerarquía de memoria de un ordenador. Se encuentran dentro de la CPU, y se usan para almacenar operandos y resultados de las operaciones que hace la CPU. Los registros se miden por el número de bits que almacenan, por ejemplo: un registro de 8 bits, o un registros de 32 bits, o un registro de 64 bits. Dependiendo de la arquitectura se tienen más o menos registros de más o menos bits.

\item {} 
\sphinxAtStartPar
Una \sphinxstylestrong{Unidad de Control} que manda señales al resto de componentes para que todas las partes estén sincronizadas. Se comporta como los semáforos que regulan el tráfico en los cruces dejando actuar a unos y deteniendo a otros. Además, esta Unidad de Control usa una serie de registros especiales como son: un \sphinxstylestrong{registro de instrucciones} donde se almacena la instrucción que se está ejecutando y un \sphinxstylestrong{contador de programa} donde se almacena la dirección de la memoria donde está la instrucción que se está ejecutando.

\end{itemize}


\subsection{Memoria principal}
\label{\detokenize{software_hardware:memoria-principal}}
\sphinxAtStartPar
Esta es la memoria del ordenador que nosotros solemos conocer coloquialmente como «memoria RAM». En esta memoria se almacenan los programas, es decir, todas las instrucciones de todos los programas que se están ejecutando en un ordenador más los datos.


\subsection{Unidad de Entrada/Salida}
\label{\detokenize{software_hardware:unidad-de-entrada-salida}}
\sphinxAtStartPar
O unidad de E/S es el mecanismo que permite conectar al ordenador todo tipo de periféricos para ampliar las opciones de un ordenador. Por ejemplo, una impresora, un ratón o un teclado es conectado a este mecanismo.


\section{Software y clasificación del software}
\label{\detokenize{software_hardware:software-y-clasificacion-del-software}}
\sphinxAtStartPar
El software es el conjunto de programas informáticos que actúan sobre el hardware para ejecutar lo que el usuario desee.

\sphinxAtStartPar
Si bien esta distinción es, en cierto modo, arbitraria, y a veces confusa, para fines prácticos se puede clasificar el software en tres tipos: software de sistema, software de programación y software de aplicación.

\sphinxAtStartPar
En el siguiente gráfico te resumo esta clasificación, con sus objetivos y algunos ejemplos de cada categoría:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{tipos_software}.png}
\caption{Tipos de software con objetivos y ejemplos}\label{\detokenize{software_hardware:id3}}\end{figure}

\sphinxstepscope


\chapter{Relación software\sphinxhyphen{}hardware}
\label{\detokenize{relacion_sw_hw:relacion-software-hardware}}\label{\detokenize{relacion_sw_hw::doc}}
\sphinxAtStartPar
Un ordenador consta de un buen número de elementos hardware, y su programación es compleja. En este ciclo vas a aprender a crear software de aplicación, en concreto aplicaciones web. Así pues, no vas a programar el ordenador directamente.

\sphinxAtStartPar
Como ves en el siguiente gráfico, solo el sistema operativo (que es un software de sistema) accede directamente al hardware. El resto de aplicaciones se programan sobre el sistema operativo.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.300\linewidth]{{relacion_sw_hw}.png}
\caption{Relación jerárquica entre el software y el hardware de un ordenador}\label{\detokenize{relacion_sw_hw:id1}}\end{figure}


\section{Sistemas operativos}
\label{\detokenize{relacion_sw_hw:sistemas-operativos}}
\sphinxAtStartPar
En el mundo de los ordenadores personales hay tres sistemas operativos más o menos populares, que seguramente ya conocerás: Windows, MacOS y Linux.

\sphinxAtStartPar
El sistema operativo es, en realidad, un \sphinxstylestrong{conjunto de programas de sistema que gestiona los recursos hardware} y provee servicios (una interfaz) a los programas de aplicación. Resumiendo, sus funciones principales son:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Gestionar la memoria} de acceso aleatorio y ejecutar las aplicaciones, designando los recursos necesarios.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Administrar la CPU} gracias a un algoritmo de programación.

\item {} 
\sphinxAtStartPar
Direccionar las \sphinxstylestrong{entradas y salidas} de datos (a través de drivers) por medio de los periféricos de entrada o salida.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Administrar la información} para el buen funcionamiento del PC.

\item {} 
\sphinxAtStartPar
Dirigir las autorizaciones de uso para los \sphinxstylestrong{usuarios}.

\end{itemize}


\section{Aplicaciones}
\label{\detokenize{relacion_sw_hw:aplicaciones}}
\sphinxAtStartPar
Las aplicaciones son \sphinxstylestrong{programas de usuario} y son escritas por medio de \sphinxstylestrong{lenguajes de programación}.

\sphinxAtStartPar
Hay multitud de lenguajes de programación pero todos, hoy en día, tienen una característica en común: usan un léxico, sintaxis y semántica fácil de aprender y usar por el ser humano. Las sentencias de un lenguaje de programación tienen que ser traducidas a un lenguaje o códigos que la máquina pueda interpretar y ejecutar.

\sphinxAtStartPar
Como sabes, una máquina como el ordenador solo es capaz de interpretar señales eléctricas (ausencia o presencia de tensión) que, nosotros interpretamos como 0 (no hay tensión o corriente) y 1 (hay tensión o corriente). A esta codificación la conocemos como \sphinxstylestrong{binario}.

\sphinxAtStartPar
En los siguientes apartados vamos a entrar de lleno en los lenguajes de programación, podrás ver que hay varios tipos de lenguajes de programación y de qué forma se pueden traducir las sentencias de alto nivel a código máquina.

\sphinxstepscope


\chapter{Lenguajes de programación: evolución histórica}
\label{\detokenize{lenguajes_programacion_evolucion_historica:lenguajes-de-programacion-evolucion-historica}}\label{\detokenize{lenguajes_programacion_evolucion_historica::doc}}
\sphinxAtStartPar
Los lenguajes de programación han sufrido una evolución importante. Los primeros ordenadores eran programados por medio de \sphinxstylestrong{lenguaje máquina}, en binario directamente; con el \sphinxstylestrong{lenguaje ensamblador} se facilitó la programación añadiendo mnemotécnicos y alejándose del código binario; por último, hoy en día, tenemos \sphinxstylestrong{lenguajes de alto nivel} que son fáciles de aprender y, además, hacen la programación más fácil.

\sphinxAtStartPar
En los siguientes apartados te explico brevemente cómo funciona cada uno de los tres tipos de lenguajes.


\section{Lenguaje máquina}
\label{\detokenize{lenguajes_programacion_evolucion_historica:lenguaje-maquina}}
\sphinxAtStartPar
Se trata de un lenguaje de programación de bajo nivel, consistente en \sphinxstylestrong{instrucciones en binario} que se usan para el control de un procesador o CPU. Cada instrucción hace que la CPU realice una tarea específica como: cargar un valor en un registro, almacenar un valor en memoria, saltar a una posición de memoria dada o realizar una operación aritmético\sphinxhyphen{}lógica, por ejemplo.

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
Hoy en día escribir programas en lenguaje máquina es muy raro.
\end{sphinxadmonition}

\sphinxAtStartPar
Cada CPU tiene un juego de instrucciones. Si quieres programar en lenguaje máquina tienes que aprender a usar el juego de instrucciones de la CPU a programar, y no te servirá para otra CPU.

\sphinxAtStartPar
Por ejemplo, en las CPU de arquitectura MIPS todas las instrucciones son de 32 bits. Te muestro, a continuación, la instrucción que se usaría para cargar el valor que hay en la celda de memoria 68 a partir de la 8ª celda al registro número 8:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{100011} \PYG{l+m+mi}{00011} \PYG{l+m+mi}{01000} \PYG{l+m+mi}{00000} \PYG{l+m+mi}{00001} \PYG{l+m+mi}{000100}
\end{sphinxVerbatim}

\sphinxAtStartPar
Estos son los significados de los bits:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{l+m+mi}{100011}    \PYG{l+m+mi}{00011}    \PYG{l+m+mi}{01000}    \PYG{l+m+mi}{00000} \PYG{l+m+mi}{00001} \PYG{l+m+mi}{000100}
\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}  \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}  \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}  \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}
    \PYG{o}{|}        \PYG{o}{|}        \PYG{o}{|}              \PYG{o}{|}
    \PYG{o}{|}        \PYG{o}{|}        \PYG{o}{|}              \PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Dirección} \PYG{n}{de} \PYG{n}{memoria}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{n}{en} \PYG{n}{decimal}
    \PYG{o}{|}        \PYG{o}{|}        \PYG{o}{|}
    \PYG{o}{|}        \PYG{o}{|}        \PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Número} \PYG{n}{a} \PYG{n}{partir} \PYG{k}{del} \PYG{n}{cual} \PYG{n}{se} \PYG{n}{busca} \PYG{n}{en} \PYG{n}{memoria}\PYG{p}{:} \PYG{l+m+mi}{8} \PYG{n}{en} \PYG{n}{decimal}
    \PYG{o}{|}        \PYG{o}{|}
    \PYG{o}{|}        \PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Número} \PYG{n}{de} \PYG{n}{registro} \PYG{n}{donde} \PYG{n}{se} \PYG{n}{carga} \PYG{n}{el} \PYG{n}{valor}\PYG{p}{:} \PYG{l+m+mi}{3} \PYG{n}{en} \PYG{n}{decimal}
    \PYG{o}{|}
    \PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Código} \PYG{n}{de} \PYG{n}{operación}\PYG{p}{:} \PYG{l+m+mi}{35} \PYG{n}{en} \PYG{n}{decimal}
\end{sphinxVerbatim}


\section{Lenguaje ensamblador}
\label{\detokenize{lenguajes_programacion_evolucion_historica:lenguaje-ensamblador}}
\sphinxAtStartPar
Se trata de un lenguaje de bajo nivel, más sencillo de aprender y programar que el lenguaje máquina. Este lenguaje también es dependiente de la arquitectura de la CPU a programar.

\sphinxAtStartPar
En este lenguaje se usan \sphinxstylestrong{mnemotécnicos} que representan las instrucciones del microprocesador.

\sphinxAtStartPar
Los programas escritos en lenguaje ensamblador tienen que ser traducidos a lenguaje máquina para que se puedan ejecutar y, como en el caso del lenguaje máquina, no son portables de una CPU a otra.

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
Hoy en día tampoco se escriben programas en ensamblador salvo en casos muy concretos como: el \sphinxstyleemphasis{bootloader} de los sistemas operativos y otras partes del mismo que tienen que ver con la parte que arranca y carga el sistema operativo en la memoria.
\end{sphinxadmonition}

\sphinxAtStartPar
Por ejemplo, en las CPU de arquitectura x86, para cargar el número 61 en hexadecimal (97 en decimal) al registro \sphinxcode{\sphinxupquote{AL}} se haría de la siguiente manera en ensamblador:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MOV} \PYG{n}{AL}\PYG{p}{,} \PYG{l+m+mi}{61}\PYG{n}{h}
\end{sphinxVerbatim}

\sphinxAtStartPar
Una vez traducida esta instrucción a binario, lenguaje máquina, quedaría tal cual:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{10110000} \PYG{l+m+mi}{01100001}
\end{sphinxVerbatim}

\sphinxAtStartPar
Estos bits tienen el siguiente significado:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1011}   \PYG{l+m+mi}{0000}   \PYG{l+m+mi}{01100001}
   \PYG{o}{|}     \PYG{o}{|}         \PYG{o}{|}
   \PYG{o}{|}     \PYG{o}{|}         \PYG{o}{|}
   \PYG{o}{|}     \PYG{o}{|}         \PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Número} \PYG{l+m+mi}{61} \PYG{n}{en} \PYG{n}{hexadecimal} \PYG{n}{o} \PYG{l+m+mi}{97} \PYG{n}{en} \PYG{n}{decimal}
   \PYG{o}{|}     \PYG{o}{|}
   \PYG{o}{|}     \PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Código} \PYG{n}{para} \PYG{n}{el} \PYG{n}{registro} \PYG{n}{AL} \PYG{p}{(}\PYG{n}{número} \PYG{l+m+mi}{0} \PYG{n}{en} \PYG{n}{decimal}\PYG{p}{)}
   \PYG{o}{|}
   \PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Código} \PYG{n}{para} \PYG{n}{la} \PYG{n}{instrucción} \PYG{n}{MOV} \PYG{p}{(}\PYG{n}{mover} \PYG{n}{un} \PYG{n}{valor} \PYG{n}{a} \PYG{n}{un} \PYG{n}{registro}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Por último, te muestro un programa escrito en ensamblador para CPU de arquitectura x86 que suma los números 14 y 10:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+na}{.globl} \PYG{n+no}{main}
    \PYG{n+na}{.type} \PYG{n+no}{main}\PYG{p}{,} \PYG{n+na}{@function}

\PYG{n+nl}{main:}
    \PYG{n+nf}{movl} \PYG{n+no}{\PYGZdl{}14}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}eax}
    \PYG{n+nf}{movl} \PYG{n+no}{\PYGZdl{}10}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}ebx}
    \PYG{n+nf}{add} \PYG{n+nv}{\PYGZpc{}eax}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}ebx}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
En los lenguajes ensamblador, como ves, se usan identificadores para las instrucciones y registros de la CPU. Así, \sphinxcode{\sphinxupquote{eax}}, \sphinxcode{\sphinxupquote{ebx}} o \sphinxcode{\sphinxupquote{ebx}} son identificadores de tres de los registros de las CPU x86. Y \sphinxcode{\sphinxupquote{movl}} o \sphinxcode{\sphinxupquote{add}} son instrucciones de la arquitectura de CPU x86.
\end{sphinxadmonition}


\section{Lenguaje de alto nivel}
\label{\detokenize{lenguajes_programacion_evolucion_historica:lenguaje-de-alto-nivel}}
\sphinxAtStartPar
Estos lenguajes son fáciles de usar y aprender porque \sphinxstylestrong{usan un léxico, sintaxis y semántica cercano al ser humano}. Estos lenguajes ocultan los detalles de la arquitectura de la CPU a programar, no hace falta aprenderse el juego de instrucciones del microprocesador, lo que hace mucho más fácil la programación. Así pues, estos lenguajes no dependen de la arquitectura de la CPU.

\sphinxAtStartPar
Cuando aprendes a usar un lenguaje de alto nivel es fácil la transición a otro lenguaje. Por ejemplo, si aprendes a programar en \sphinxcode{\sphinxupquote{Java}} te resultará muy fácil pasar a programar con \sphinxcode{\sphinxupquote{PHP}} o \sphinxcode{\sphinxupquote{Python}} por ejemplo.

\sphinxAtStartPar
Un ejemplo de programa en \sphinxcode{\sphinxupquote{C}} que carga dos valores en memoria y los suma dejando el resultado en otra posición de memoria sería el siguiente:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{,} \PYG{n}{resultado}\PYG{p}{;}

    \PYG{n}{num1} \PYG{o}{=} \PYG{l+m+mi}{14}\PYG{p}{;}
    \PYG{n}{num2} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

    \PYG{n}{resultado} \PYG{o}{=} \PYG{n}{num1} \PYG{o}{+} \PYG{n}{num2}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{En resumen}
\label{\detokenize{lenguajes_programacion_evolucion_historica:en-resumen}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Resumen de lenguajes de programación}\label{\detokenize{lenguajes_programacion_evolucion_historica:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{33}{99}|\X{33}{99}|\X{33}{99}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Lenguaje Máquina
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Lenguaje Ensamblador
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Lenguaje de Alto Nivel
\\
\hline
\sphinxAtStartPar
La programación es compleja
&
\sphinxAtStartPar
Facilita la programación aunque sigue siendo difícil escribir programas
&
\sphinxAtStartPar
La programación es fácil
\\
\hline
\sphinxAtStartPar
Las instrucciones son en binario
&
\sphinxAtStartPar
Se programa usando mnemotécnicos (instrucciones complejas)
&
\sphinxAtStartPar
Se utilizan sentencias y órdenes con un léxico, sintaxis y semántica cercano al lenguaje humano
\\
\hline
\sphinxAtStartPar
Estos programas se pueden ejecutar directamente
&
\sphinxAtStartPar
Necesita traducción al lenguaje máquina para poder ejecutarse
&
\sphinxAtStartPar
Necesita traducción al lenguaje máquina para poder ejecutarse
\\
\hline
\sphinxAtStartPar
Es único para cada procesador (no es portable de un equipo a otro)
&
\sphinxAtStartPar
Hay diferentes lenguajes de ensamblador por cada arquitectura de CPU
&
\sphinxAtStartPar
Son independientes de la CPU
\\
\hline
\sphinxAtStartPar
Hoy día nadie programa en este lenguaje
&
\sphinxAtStartPar
Se usa en caso muy concretos, sobre todo en el desarrollo de programas de sistema
&
\sphinxAtStartPar
Son los que se usan hoy en día
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\chapter{Práctica 1: Introducción al desarrollo de software y lenguajes de programación}
\label{\detokenize{practica1:practica-1-introduccion-al-desarrollo-de-software-y-lenguajes-de-programacion}}\label{\detokenize{practica1::doc}}
\sphinxAtStartPar
En esta práctica tienes que responder a una serie de preguntas de tipo test. Aquí te dejo las preguntas. Llegado el momento te indicaré cómo y dónde tienes que responder a estas cuestiones:
\begin{itemize}
\item {} 
\sphinxAtStartPar
En la Arquitectura von Neumann se describen los siguientes componentes.

\item {} 
\sphinxAtStartPar
Dentro de una CPU encontramos las siguientes unidades funcionales.

\item {} 
\sphinxAtStartPar
¿Dónde se cargan los programas a ser ejecutados?

\item {} 
\sphinxAtStartPar
¿Quién ejecuta los programas?

\item {} 
\sphinxAtStartPar
Si se tiene que hacer una suma, a nivel hardware, ¿qué unidad funcional la realizará?

\item {} 
\sphinxAtStartPar
¿Quién gestiona la carga de los programas de usuario (aplicaciones) en la memoria para ser ejecutados?

\item {} 
\sphinxAtStartPar
¿Qué software tiene acceso al hardware del ordenador?

\item {} 
\sphinxAtStartPar
¿Cuál fue la evolución histórica de los lenguajes de programación (de más antiguo a más actual)?

\item {} 
\sphinxAtStartPar
¿Qué lenguaje o lenguajes puedes usar para escribir programas que puedan ser ejecutados directamente por la CPU, sin traducción?

\item {} 
\sphinxAtStartPar
¿En qué lenguaje ha sido escrita la siguiente instrucción: 00011 00011 01000 00000 00001 000100?

\item {} 
\sphinxAtStartPar
¿En qué lenguaje ha sido escrita la siguiente instrucción: MOVL \$10, \%ebx?

\item {} 
\sphinxAtStartPar
¿En qué lenguaje ha sido escrita la siguiente instrucción: int num1 = 10;?

\end{itemize}


\section{Criterios de evaluación}
\label{\detokenize{practica1:criterios-de-evaluacion}}
\sphinxAtStartPar
En esta práctica se aplica el \sphinxcode{\sphinxupquote{Resultado de Aprendizaje 1: reconoce los elementos y herramientas que intervienen en el desarrollo de un programa informático, analizando sus características y las fases en las que actúan hasta llegar a su puesta en funcionamiento.}}. Y en concreto los siguientes criterios de evaluación:
\begin{itemize}
\item {} \begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Se ha reconocido la relación de los programas con los componentes del sistema informático: memoria, procesador y periféricos,  entre otros. (10\%)

\end{enumerate}

\item {} \begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Se han clasificado los lenguajes de programación. (20\%)

\end{enumerate}

\end{itemize}

\sphinxstepscope


\chapter{Lenguajes de alto nivel: clasificación}
\label{\detokenize{lenguajes_alto_nivel_clasificacion:lenguajes-de-alto-nivel-clasificacion}}\label{\detokenize{lenguajes_alto_nivel_clasificacion::doc}}
\sphinxAtStartPar
En el apartado anterior ya estudiamos la evolución histórica de los lenguajes de programación: máquina, ensamblador y alto nivel.

\sphinxAtStartPar
En este apartado nos vamos a centrar en los lenguajes de alto nivel, que al final son estos con los que vas a aprender a programar en este ciclo.

\sphinxAtStartPar
Dentro del mundo de los lenguajes de alto nivel existen varios paradigmas que determinan, en cierto modo, cómo se escriben y estructuran los programas. Algunos de los paradigmas más populares son: programación estructurada, programación modular y programación orientada a objetos (POO).


\sphinxstrong{Ver también:}
\nopagebreak


\sphinxAtStartPar
\sphinxstylestrong{Speedcoding}, \sphinxstylestrong{Speedcode} o \sphinxstylestrong{SpeedCo} es el primer lenguaje de alto nivel, creado para un ordenador IBM 701 por John W. Backus en 1953.

\sphinxAtStartPar
No obstante, el primer lenguaje con cierta popularidad fue \sphinxstylestrong{Fortran}, creado por la propia IBM en 1957. Hoy en día se sigue usando.

\sphinxAtStartPar
Fue en 1972, cuando Dennis Ritchie  diseñó el lenguaje \sphinxstylestrong{C} que ha influenciado a casi la totalidad de lenguajes populares de hoy en día, como \sphinxstylestrong{C++}, \sphinxstylestrong{Java}, \sphinxstylestrong{Python}, \sphinxstylestrong{PHP} o \sphinxstylestrong{JavaScript}, por ejemplo. Hoy en día, \sphinxstylestrong{C} es ampliamente utilizado para la creació de programas de sistema como son los sistemas operativos y aplicaciones para sistemas embebidos.




\section{Código espagueti: paradigma a evitar}
\label{\detokenize{lenguajes_alto_nivel_clasificacion:codigo-espagueti-paradigma-a-evitar}}
\sphinxAtStartPar
El código espagueti es un \sphinxstylestrong{término peyorativo} para los programas de computación que tienen una estructura de control de flujo compleja e incomprensible. Su nombre deriva del hecho que este tipo de código parece asemejarse a un plato de espaguetis, es decir, un montón de hilos intrincados y anudados.

\sphinxAtStartPar
Tradicionalmente suele asociarse este estilo de programación con lenguajes básicos y antiguos, donde el flujo se controlaba mediante sentencias de control muy primitivas como goto y utilizando números de línea.

\sphinxAtStartPar
Para evitar este \sphinxstyleemphasis{paradigma} hay que emplear alguno de los paradigmas que te explico en los siguientes apartados.


\section{Programación estructurada}
\label{\detokenize{lenguajes_alto_nivel_clasificacion:programacion-estructurada}}
\sphinxAtStartPar
Este es un paradigma de programación cuyo objetivo es mejorar la claridad, calidad y el tiempo de desarrollo de los programas haciendo un uso extensivo de:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Estructuras de control de selección del flujo \sphinxcode{\sphinxupquote{if/then/else}}.

\item {} 
\sphinxAtStartPar
Estructuras de control de repetición (bucles) \sphinxcode{\sphinxupquote{while}} y \sphinxcode{\sphinxupquote{for}}.

\item {} 
\sphinxAtStartPar
Estructuras de bloque: bloques de código relacionados y agrupados de alguna manera.

\item {} 
\sphinxAtStartPar
Subrutinas: secuencias de instrucciones del programa que realizan una tarea específica, agrupadas como una unidad.

\end{itemize}

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
En diferentes lenguajes de programación, a las \sphinxstylestrong{subrutinas} se les puede llamar: \sphinxstylestrong{rutina}, \sphinxstylestrong{subprograma}, \sphinxstylestrong{función}, \sphinxstylestrong{método} o \sphinxstylestrong{procedimiento}.
\end{sphinxadmonition}

\sphinxAtStartPar
Las ventajas de este paradigma son:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Los programas son más fáciles de entender y leer.

\item {} 
\sphinxAtStartPar
Los programas son más rápidos.

\item {} 
\sphinxAtStartPar
La estructura de los programas es clara.

\item {} 
\sphinxAtStartPar
Se construyen programas con más rapidez.

\item {} 
\sphinxAtStartPar
Se facilita la depuración y detección de errores.

\item {} 
\sphinxAtStartPar
Se reducen los costes de mantenimiento.

\end{itemize}

\sphinxAtStartPar
Los inconvenientes de este paradigma son:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Todo el programa se concentra en un único bloque (si se hace demasiado grande es difícil de manejar y mantener).

\item {} 
\sphinxAtStartPar
No permite reutilización eficaz de código, ya que todo va «en uno». Es por esto que a la programación estructurada le sustituyó  la programación modular, donde los programas se codifican por módulos y bloques, permitiendo mayor funcionalidad.

\end{itemize}

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
Ejemplos de lenguajes estructurados: \sphinxstylestrong{Fortran}, \sphinxstylestrong{Pascal} y \sphinxstylestrong{C}.
\end{sphinxadmonition}


\section{Programación modular}
\label{\detokenize{lenguajes_alto_nivel_clasificacion:programacion-modular}}
\sphinxAtStartPar
La programación modular es un paradigma de programación que consiste en dividir un programa en módulos o subprogramas con el fin de hacerlo más legible y manejable.

\sphinxAtStartPar
Se presenta históricamente como una evolución de la programación estructurada para solucionar problemas de programación más grandes y complejos de lo que esta puede resolver.

\sphinxAtStartPar
Esto se suele traducir en que un programa está formado por varios ficheros, y en la práctica cada fichero sería un modulo, una parte del programa, que se ha dividido en diferentes piezas.

\sphinxAtStartPar
Está a medio camino entre la programación estructurada y la programación orientada a objetos.


\section{Programación orientada a objetos}
\label{\detokenize{lenguajes_alto_nivel_clasificacion:programacion-orientada-a-objetos}}
\sphinxAtStartPar
Después de comprender que la programación estructurada no es útil cuando los programas se hacen muy largos, es necesaria otra  técnica de programación que solucione este inconveniente. Nace así la programación orientada a objetos.

\sphinxAtStartPar
Los lenguajes de programación orientados a objetos tratan a los programas no como un conjunto ordenado de instrucciones (tal como sucedía en la programación estructurada) sino como un conjunto de objetos que colaboran entre ellos para realizar acciones.

\sphinxAtStartPar
Su primera desventaja es clara: no es una programación tan intuitiva como la estructurada.

\sphinxAtStartPar
A pesar de eso, mucho del software que produce se hace usando esta técnica por las siguientes razones:
\begin{itemize}
\item {} 
\sphinxAtStartPar
El código es reutilizable.

\item {} 
\sphinxAtStartPar
Si hay algún error, es más fácil de localizar y depurar en un objeto que en un programa entero.

\end{itemize}

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
Ejemplos de lenguajes orientados a objetos: \sphinxstylestrong{C++} y \sphinxstylestrong{Java}.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Fases en la obtención del código}
\label{\detokenize{obtencion_del_codigo:fases-en-la-obtencion-del-codigo}}\label{\detokenize{obtencion_del_codigo::doc}}
\sphinxAtStartPar
Como ya sabes los programas escritos usando un lenguaje de alto nivel necesitan ser traducidos a lenguaje máquina. ¿Cómo se obtiene el código máquina o ejecutable? Es lo que vas a aprender en este apartado.

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
Para ilustrar los ejemplos voy a usar el lenguaje de programación C.
\end{sphinxadmonition}


\section{Código fuente, objeto y ejecutable}
\label{\detokenize{obtencion_del_codigo:codigo-fuente-objeto-y-ejecutable}}
\sphinxAtStartPar
Antes tienes que saber que existen tres tipos de código: código \sphinxstylestrong{fuente}, código \sphinxstylestrong{objeto} y código \sphinxstylestrong{ejecutable o máquina}.


\subsection{Código fuente}
\label{\detokenize{obtencion_del_codigo:codigo-fuente}}
\sphinxAtStartPar
Se trata de los ficheros con el \sphinxstylestrong{código escrito en alto nivel} del lenguaje de programación escogido para la programación. También se denomina código fuente a los programas escritos en \sphinxstylestrong{ensamblador}. Un programa puede estar escrito en uno o varios ficheros.

\sphinxAtStartPar
A continuación te muestro el código fuente de un programa escrito en C y su equivalente en ensamblador. Se trata de un programa que suma dos números y muestra el resultado por pantalla.

\begin{sphinxuseclass}{sphinx-tabs}
\begin{sphinxuseclass}{closeable}
\sphinxAtStartPar
Código fuente en C

\sphinxAtStartPar
Código fuente en ensamblador

\end{sphinxuseclass}
\begin{sphinxuseclass}{sphinx-tabs-panel}
\begin{sphinxuseclass}{group-tab}\sphinxSetupCaptionForVerbatim{Programa escrito en C que suma dos números y muestra el resultado por pantalla}
\def\sphinxLiteralBlockLabel{\label{\detokenize{obtencion_del_codigo:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{,} \PYG{n}{resultado}\PYG{p}{;}

    \PYG{n}{num1} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}
    \PYG{n}{num2} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}

    \PYG{n}{resultado} \PYG{o}{=} \PYG{n}{num1} \PYG{o}{+} \PYG{n}{num2}\PYG{p}{;}

    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Resultado de sumar \PYGZpc{}d y \PYGZpc{}d = \PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{,} \PYG{n}{resultado}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sphinx-tabs-panel}
\begin{sphinxuseclass}{group-tab}\sphinxSetupCaptionForVerbatim{Programa escrito en ensamblador que suma dos números y muestra el resultado por pantalla}
\def\sphinxLiteralBlockLabel{\label{\detokenize{obtencion_del_codigo:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n+na}{.file}   \PYG{l+s}{\PYGZdq{}main.c\PYGZdq{}}
    \PYG{n+na}{.text}
    \PYG{n+na}{.section}    \PYG{n+no}{.rodata}
    \PYG{n+na}{.align} \PYG{l+m+mi}{8}
\PYG{n+nl}{.LC0:}
    \PYG{n+na}{.string} \PYG{l+s}{\PYGZdq{}Resultado de sumar \PYGZpc{}d y \PYGZpc{}d = \PYGZpc{}d\PYGZbs{}n\PYGZdq{}}
    \PYG{n+na}{.text}
    \PYG{n+na}{.globl}  \PYG{n+no}{main}
    \PYG{n+na}{.type}   \PYG{n+no}{main}\PYG{p}{,} \PYG{n+na}{@function}
\PYG{n+nl}{main:}
\PYG{n+nl}{.LFB0:}
    \PYG{n+na}{.cfi\PYGZus{}startproc}
    \PYG{n+nf}{pushq}   \PYG{n+nv}{\PYGZpc{}rbp}
    \PYG{n+na}{.cfi\PYGZus{}def\PYGZus{}cfa\PYGZus{}offset} \PYG{l+m+mi}{16}
    \PYG{n+na}{.cfi\PYGZus{}offset} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{\PYGZhy{}16}
    \PYG{n+nf}{movq}    \PYG{n+nv}{\PYGZpc{}rsp}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}rbp}
    \PYG{n+na}{.cfi\PYGZus{}def\PYGZus{}cfa\PYGZus{}register} \PYG{l+m+mi}{6}
    \PYG{n+nf}{subq}    \PYG{n+no}{\PYGZdl{}32}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}rsp}
    \PYG{n+nf}{movl}    \PYG{n+nv}{\PYGZpc{}edi}\PYG{p}{,} \PYG{l+m+mi}{\PYGZhy{}20}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{)}
    \PYG{n+nf}{movq}    \PYG{n+nv}{\PYGZpc{}rsi}\PYG{p}{,} \PYG{l+m+mi}{\PYGZhy{}32}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{)}
    \PYG{n+nf}{movl}    \PYG{n+no}{\PYGZdl{}15}\PYG{p}{,} \PYG{l+m+mi}{\PYGZhy{}4}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{)}
    \PYG{n+nf}{movl}    \PYG{n+no}{\PYGZdl{}20}\PYG{p}{,} \PYG{l+m+mi}{\PYGZhy{}8}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{)}
    \PYG{n+nf}{movl}    \PYG{l+m+mi}{\PYGZhy{}4}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{),} \PYG{n+nv}{\PYGZpc{}edx}
    \PYG{n+nf}{movl}    \PYG{l+m+mi}{\PYGZhy{}8}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{),} \PYG{n+nv}{\PYGZpc{}eax}
    \PYG{n+nf}{addl}    \PYG{n+nv}{\PYGZpc{}edx}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}eax}
    \PYG{n+nf}{movl}    \PYG{n+nv}{\PYGZpc{}eax}\PYG{p}{,} \PYG{l+m+mi}{\PYGZhy{}12}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{)}
    \PYG{n+nf}{movl}    \PYG{l+m+mi}{\PYGZhy{}12}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{),} \PYG{n+nv}{\PYGZpc{}ecx}
    \PYG{n+nf}{movl}    \PYG{l+m+mi}{\PYGZhy{}8}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{),} \PYG{n+nv}{\PYGZpc{}edx}
    \PYG{n+nf}{movl}    \PYG{l+m+mi}{\PYGZhy{}4}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rbp}\PYG{p}{),} \PYG{n+nv}{\PYGZpc{}eax}
    \PYG{n+nf}{movl}    \PYG{n+nv}{\PYGZpc{}eax}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}esi}
    \PYG{n+nf}{leaq}    \PYG{n+no}{.LC0}\PYG{p}{(}\PYG{n+nv}{\PYGZpc{}rip}\PYG{p}{),} \PYG{n+nv}{\PYGZpc{}rdi}
    \PYG{n+nf}{movl}    \PYG{n+no}{\PYGZdl{}0}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}eax}
    \PYG{n+nf}{call}    \PYG{n+no}{printf@PLT}
    \PYG{n+nf}{movl}    \PYG{n+no}{\PYGZdl{}0}\PYG{p}{,} \PYG{n+nv}{\PYGZpc{}eax}
    \PYG{n+nf}{leave}
    \PYG{n+na}{.cfi\PYGZus{}def\PYGZus{}cfa} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}
    \PYG{n+nf}{ret}
    \PYG{n+na}{.cfi\PYGZus{}endproc}
\PYG{n+nl}{.LFE0:}
    \PYG{n+na}{.size}   \PYG{n+no}{main}\PYG{p}{,} \PYG{n+no}{.\PYGZhy{}main}
    \PYG{n+na}{.ident}  \PYG{l+s}{\PYGZdq{}GCC: (Debian 10.2.1\PYGZhy{}6) 10.2.1 20210110\PYGZdq{}}
    \PYG{n+na}{.section}        \PYG{n+no}{.note.GNU\PYGZhy{}stack}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{,}\PYG{n+na}{@progbits}
\end{sphinxVerbatim}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{Código objeto}
\label{\detokenize{obtencion_del_codigo:codigo-objeto}}
\sphinxAtStartPar
Es el \sphinxstylestrong{código binario resultante de traducir cada fichero fuente}. Este código no es inteligible por el ser humano pero tampoco está listo para ser ejecutado por la CPU.

\sphinxAtStartPar
Aquí te muestro el código \sphinxstyleemphasis{desensamblado} en hexadecimal, donde se indican las direcciones de la memoria virtual donde se cargará el programa y las instrucciones, también en hexadecimal.

\sphinxAtStartPar
Por cuestiones de claridad, a la derecha tienes el código ensamblador equivalente.
\sphinxSetupCaptionForVerbatim{Código objeto del programa anterior desensamblado (a la derecha tienes el código en ensamblador)}
\def\sphinxLiteralBlockLabel{\label{\detokenize{obtencion_del_codigo:id3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0000000000000000 \PYGZlt{}main\PYGZgt{}:
0:  55                      push   \PYGZpc{}rbp
1:  48 89 e5                mov    \PYGZpc{}rsp,\PYGZpc{}rbp
4:  48 83 ec 20             sub    \PYGZdl{}0x20,\PYGZpc{}rsp
8:  89 7d ec                mov    \PYGZpc{}edi,\PYGZhy{}0x14(\PYGZpc{}rbp)
b:  48 89 75 e0             mov    \PYGZpc{}rsi,\PYGZhy{}0x20(\PYGZpc{}rbp)
f:  c7 45 fc 0f 00 00 00    movl   \PYGZdl{}0xf,\PYGZhy{}0x4(\PYGZpc{}rbp)
16: c7 45 f8 14 00 00 00    movl   \PYGZdl{}0x14,\PYGZhy{}0x8(\PYGZpc{}rbp)
1d: 8b 55 fc                mov    \PYGZhy{}0x4(\PYGZpc{}rbp),\PYGZpc{}edx
20: 8b 45 f8                mov    \PYGZhy{}0x8(\PYGZpc{}rbp),\PYGZpc{}eax
23: 01 d0                   add    \PYGZpc{}edx,\PYGZpc{}eax
25: 89 45 f4                mov    \PYGZpc{}eax,\PYGZhy{}0xc(\PYGZpc{}rbp)
28: 8b 4d f4                mov    \PYGZhy{}0xc(\PYGZpc{}rbp),\PYGZpc{}ecx
2b: 8b 55 f8                mov    \PYGZhy{}0x8(\PYGZpc{}rbp),\PYGZpc{}edx
2e: 8b 45 fc                mov    \PYGZhy{}0x4(\PYGZpc{}rbp),\PYGZpc{}eax
31: 89 c6                   mov    \PYGZpc{}eax,\PYGZpc{}esi
33: 48 8d 3d 00 00 00 00    lea    0x0(\PYGZpc{}rip),\PYGZpc{}rdi        \PYGZsh{} 3a \PYGZlt{}main+0x3a\PYGZgt{}
3a: b8 00 00 00 00          mov    \PYGZdl{}0x0,\PYGZpc{}eax
3f: e8 00 00 00 00          callq  44 \PYGZlt{}main+0x44\PYGZgt{}
44: b8 00 00 00 00          mov    \PYGZdl{}0x0,\PYGZpc{}eax
49: c9                      leaveq
4a: c3                      retq
\end{sphinxVerbatim}


\subsection{Código ejecutable o máquina}
\label{\detokenize{obtencion_del_codigo:codigo-ejecutable-o-maquina}}
\sphinxAtStartPar
Es el código binario resultante de enlazar los archivos con el código objeto y ciertas rutinas y bibliotecas necesarias.

\sphinxAtStartPar
Siguiendo con el ejemplo anterior, aquí te muestro el código ejecutable \sphinxstyleemphasis{desensamblado}. Como ves es bastante más largo que el código objeto anterior porque se han añadido ciertas rutinas y bibliotecas necesarias, todo en un mismo fichero.

\sphinxAtStartPar
Por cuestiones de claridad, aquí también te muestro a la derecha el código ensamblador equivalente.
\sphinxSetupCaptionForVerbatim{Código ejecutable o máquina del programa anterior (a la derecha se muestra el código ensamblador equivalente)}
\def\sphinxLiteralBlockLabel{\label{\detokenize{obtencion_del_codigo:id4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0000000000001000 \PYGZlt{}\PYGZus{}init\PYGZgt{}:
    1000:   48 83 ec 08             sub    \PYGZdl{}0x8,\PYGZpc{}rsp
    1004:   48 8b 05 dd 2f 00 00    mov    0x2fdd(\PYGZpc{}rip),\PYGZpc{}rax        \PYGZsh{} 3fe8 \PYGZlt{}\PYGZus{}\PYGZus{}gmon\PYGZus{}start\PYGZus{}\PYGZus{}\PYGZgt{}
    100b:   48 85 c0                test   \PYGZpc{}rax,\PYGZpc{}rax
    100e:   74 02                   je     1012 \PYGZlt{}\PYGZus{}init+0x12\PYGZgt{}
    1010:   ff d0                   callq  *\PYGZpc{}rax
    1012:   48 83 c4 08             add    \PYGZdl{}0x8,\PYGZpc{}rsp
    1016:   c3                      retq

Desensamblado de la sección .plt:

0000000000001020 \PYGZlt{}.plt\PYGZgt{}:
    1020:   ff 35 e2 2f 00 00       pushq  0x2fe2(\PYGZpc{}rip)        \PYGZsh{} 4008 \PYGZlt{}\PYGZus{}GLOBAL\PYGZus{}OFFSET\PYGZus{}TABLE\PYGZus{}+0x8\PYGZgt{}
    1026:   ff 25 e4 2f 00 00       jmpq   *0x2fe4(\PYGZpc{}rip)        \PYGZsh{} 4010 \PYGZlt{}\PYGZus{}GLOBAL\PYGZus{}OFFSET\PYGZus{}TABLE\PYGZus{}+0x10\PYGZgt{}
    102c:   0f 1f 40 00             nopl   0x0(\PYGZpc{}rax)

0000000000001030 \PYGZlt{}printf@plt\PYGZgt{}:
    1030:   ff 25 e2 2f 00 00       jmpq   *0x2fe2(\PYGZpc{}rip)        \PYGZsh{} 4018 \PYGZlt{}printf@GLIBC\PYGZus{}2.2.5\PYGZgt{}
    1036:   68 00 00 00 00          pushq  \PYGZdl{}0x0
    103b:   e9 e0 ff ff ff          jmpq   1020 \PYGZlt{}.plt\PYGZgt{}

Desensamblado de la sección .plt.got:

0000000000001040 \PYGZlt{}\PYGZus{}\PYGZus{}cxa\PYGZus{}finalize@plt\PYGZgt{}:
    1040:   ff 25 b2 2f 00 00       jmpq   *0x2fb2(\PYGZpc{}rip)        \PYGZsh{} 3ff8 \PYGZlt{}\PYGZus{}\PYGZus{}cxa\PYGZus{}finalize@GLIBC\PYGZus{}2.2.5\PYGZgt{}
    1046:   66 90                   xchg   \PYGZpc{}ax,\PYGZpc{}ax

Desensamblado de la sección .text:

0000000000001050 \PYGZlt{}\PYGZus{}start\PYGZgt{}:
    1050:   31 ed                   xor    \PYGZpc{}ebp,\PYGZpc{}ebp
    1052:   49 89 d1                mov    \PYGZpc{}rdx,\PYGZpc{}r9
    1055:   5e                      pop    \PYGZpc{}rsi
    1056:   48 89 e2                mov    \PYGZpc{}rsp,\PYGZpc{}rdx
    1059:   48 83 e4 f0             and    \PYGZdl{}0xfffffffffffffff0,\PYGZpc{}rsp
    105d:   50                      push   \PYGZpc{}rax
    105e:   54                      push   \PYGZpc{}rsp
    105f:   4c 8d 05 7a 01 00 00    lea    0x17a(\PYGZpc{}rip),\PYGZpc{}r8        \PYGZsh{} 11e0 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}csu\PYGZus{}fini\PYGZgt{}
    1066:   48 8d 0d 13 01 00 00    lea    0x113(\PYGZpc{}rip),\PYGZpc{}rcx        \PYGZsh{} 1180 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}csu\PYGZus{}init\PYGZgt{}
    106d:   48 8d 3d c1 00 00 00    lea    0xc1(\PYGZpc{}rip),\PYGZpc{}rdi        \PYGZsh{} 1135 \PYGZlt{}main\PYGZgt{}
    1074:   ff 15 66 2f 00 00       callq  *0x2f66(\PYGZpc{}rip)        \PYGZsh{} 3fe0 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}start\PYGZus{}main@GLIBC\PYGZus{}2.2.5\PYGZgt{}
    107a:   f4                      hlt
    107b:   0f 1f 44 00 00          nopl   0x0(\PYGZpc{}rax,\PYGZpc{}rax,1)

0000000000001080 \PYGZlt{}deregister\PYGZus{}tm\PYGZus{}clones\PYGZgt{}:
    1080:   48 8d 3d a9 2f 00 00    lea    0x2fa9(\PYGZpc{}rip),\PYGZpc{}rdi        \PYGZsh{} 4030 \PYGZlt{}\PYGZus{}\PYGZus{}TMC\PYGZus{}END\PYGZus{}\PYGZus{}\PYGZgt{}
    1087:   48 8d 05 a2 2f 00 00    lea    0x2fa2(\PYGZpc{}rip),\PYGZpc{}rax        \PYGZsh{} 4030 \PYGZlt{}\PYGZus{}\PYGZus{}TMC\PYGZus{}END\PYGZus{}\PYGZus{}\PYGZgt{}
    108e:   48 39 f8                cmp    \PYGZpc{}rdi,\PYGZpc{}rax
    1091:   74 15                   je     10a8 \PYGZlt{}deregister\PYGZus{}tm\PYGZus{}clones+0x28\PYGZgt{}
    1093:   48 8b 05 3e 2f 00 00    mov    0x2f3e(\PYGZpc{}rip),\PYGZpc{}rax        \PYGZsh{} 3fd8 \PYGZlt{}\PYGZus{}ITM\PYGZus{}deregisterTMCloneTable\PYGZgt{}
    109a:   48 85 c0                test   \PYGZpc{}rax,\PYGZpc{}rax
    109d:   74 09                   je     10a8 \PYGZlt{}deregister\PYGZus{}tm\PYGZus{}clones+0x28\PYGZgt{}
    109f:   ff e0                   jmpq   *\PYGZpc{}rax
    10a1:   0f 1f 80 00 00 00 00    nopl   0x0(\PYGZpc{}rax)
    10a8:   c3                      retq
    10a9:   0f 1f 80 00 00 00 00    nopl   0x0(\PYGZpc{}rax)

00000000000010b0 \PYGZlt{}register\PYGZus{}tm\PYGZus{}clones\PYGZgt{}:
    10b0:   48 8d 3d 79 2f 00 00    lea    0x2f79(\PYGZpc{}rip),\PYGZpc{}rdi        \PYGZsh{} 4030 \PYGZlt{}\PYGZus{}\PYGZus{}TMC\PYGZus{}END\PYGZus{}\PYGZus{}\PYGZgt{}
    10b7:   48 8d 35 72 2f 00 00    lea    0x2f72(\PYGZpc{}rip),\PYGZpc{}rsi        \PYGZsh{} 4030 \PYGZlt{}\PYGZus{}\PYGZus{}TMC\PYGZus{}END\PYGZus{}\PYGZus{}\PYGZgt{}
    10be:   48 29 fe                sub    \PYGZpc{}rdi,\PYGZpc{}rsi
    10c1:   48 89 f0                mov    \PYGZpc{}rsi,\PYGZpc{}rax
    10c4:   48 c1 ee 3f             shr    \PYGZdl{}0x3f,\PYGZpc{}rsi
    10c8:   48 c1 f8 03             sar    \PYGZdl{}0x3,\PYGZpc{}rax
    10cc:   48 01 c6                add    \PYGZpc{}rax,\PYGZpc{}rsi
    10cf:   48 d1 fe                sar    \PYGZpc{}rsi
    10d2:   74 14                   je     10e8 \PYGZlt{}register\PYGZus{}tm\PYGZus{}clones+0x38\PYGZgt{}
    10d4:   48 8b 05 15 2f 00 00    mov    0x2f15(\PYGZpc{}rip),\PYGZpc{}rax        \PYGZsh{} 3ff0 \PYGZlt{}\PYGZus{}ITM\PYGZus{}registerTMCloneTable\PYGZgt{}
    10db:   48 85 c0                test   \PYGZpc{}rax,\PYGZpc{}rax
    10de:   74 08                   je     10e8 \PYGZlt{}register\PYGZus{}tm\PYGZus{}clones+0x38\PYGZgt{}
    10e0:   ff e0                   jmpq   *\PYGZpc{}rax
    10e2:   66 0f 1f 44 00 00       nopw   0x0(\PYGZpc{}rax,\PYGZpc{}rax,1)
    10e8:   c3                      retq
    10e9:   0f 1f 80 00 00 00 00    nopl   0x0(\PYGZpc{}rax)

00000000000010f0 \PYGZlt{}\PYGZus{}\PYGZus{}do\PYGZus{}global\PYGZus{}dtors\PYGZus{}aux\PYGZgt{}:
    10f0:   80 3d 39 2f 00 00 00    cmpb   \PYGZdl{}0x0,0x2f39(\PYGZpc{}rip)        \PYGZsh{} 4030 \PYGZlt{}\PYGZus{}\PYGZus{}TMC\PYGZus{}END\PYGZus{}\PYGZus{}\PYGZgt{}
    10f7:   75 2f                   jne    1128 \PYGZlt{}\PYGZus{}\PYGZus{}do\PYGZus{}global\PYGZus{}dtors\PYGZus{}aux+0x38\PYGZgt{}
    10f9:   55                      push   \PYGZpc{}rbp
    10fa:   48 83 3d f6 2e 00 00    cmpq   \PYGZdl{}0x0,0x2ef6(\PYGZpc{}rip)        \PYGZsh{} 3ff8 \PYGZlt{}\PYGZus{}\PYGZus{}cxa\PYGZus{}finalize@GLIBC\PYGZus{}2.2.5\PYGZgt{}
    1101:   00
    1102:   48 89 e5                mov    \PYGZpc{}rsp,\PYGZpc{}rbp
    1105:   74 0c                   je     1113 \PYGZlt{}\PYGZus{}\PYGZus{}do\PYGZus{}global\PYGZus{}dtors\PYGZus{}aux+0x23\PYGZgt{}
    1107:   48 8b 3d 1a 2f 00 00    mov    0x2f1a(\PYGZpc{}rip),\PYGZpc{}rdi        \PYGZsh{} 4028 \PYGZlt{}\PYGZus{}\PYGZus{}dso\PYGZus{}handle\PYGZgt{}
    110e:   e8 2d ff ff ff          callq  1040 \PYGZlt{}\PYGZus{}\PYGZus{}cxa\PYGZus{}finalize@plt\PYGZgt{}
    1113:   e8 68 ff ff ff          callq  1080 \PYGZlt{}deregister\PYGZus{}tm\PYGZus{}clones\PYGZgt{}
    1118:   c6 05 11 2f 00 00 01    movb   \PYGZdl{}0x1,0x2f11(\PYGZpc{}rip)        \PYGZsh{} 4030 \PYGZlt{}\PYGZus{}\PYGZus{}TMC\PYGZus{}END\PYGZus{}\PYGZus{}\PYGZgt{}
    111f:   5d                      pop    \PYGZpc{}rbp
    1120:   c3                      retq
    1121:   0f 1f 80 00 00 00 00    nopl   0x0(\PYGZpc{}rax)
    1128:   c3                      retq
    1129:   0f 1f 80 00 00 00 00    nopl   0x0(\PYGZpc{}rax)

0000000000001130 \PYGZlt{}frame\PYGZus{}dummy\PYGZgt{}:
    1130:   e9 7b ff ff ff          jmpq   10b0 \PYGZlt{}register\PYGZus{}tm\PYGZus{}clones\PYGZgt{}

0000000000001135 \PYGZlt{}main\PYGZgt{}:
    1135:   55                      push   \PYGZpc{}rbp
    1136:   48 89 e5                mov    \PYGZpc{}rsp,\PYGZpc{}rbp
    1139:   48 83 ec 20             sub    \PYGZdl{}0x20,\PYGZpc{}rsp
    113d:   89 7d ec                mov    \PYGZpc{}edi,\PYGZhy{}0x14(\PYGZpc{}rbp)
    1140:   48 89 75 e0             mov    \PYGZpc{}rsi,\PYGZhy{}0x20(\PYGZpc{}rbp)
    1144:   c7 45 fc 0f 00 00 00    movl   \PYGZdl{}0xf,\PYGZhy{}0x4(\PYGZpc{}rbp)
    114b:   c7 45 f8 14 00 00 00    movl   \PYGZdl{}0x14,\PYGZhy{}0x8(\PYGZpc{}rbp)
    1152:   8b 55 fc                mov    \PYGZhy{}0x4(\PYGZpc{}rbp),\PYGZpc{}edx
    1155:   8b 45 f8                mov    \PYGZhy{}0x8(\PYGZpc{}rbp),\PYGZpc{}eax
    1158:   01 d0                   add    \PYGZpc{}edx,\PYGZpc{}eax
    115a:   89 45 f4                mov    \PYGZpc{}eax,\PYGZhy{}0xc(\PYGZpc{}rbp)
    115d:   8b 4d f4                mov    \PYGZhy{}0xc(\PYGZpc{}rbp),\PYGZpc{}ecx
    1160:   8b 55 f8                mov    \PYGZhy{}0x8(\PYGZpc{}rbp),\PYGZpc{}edx
    1163:   8b 45 fc                mov    \PYGZhy{}0x4(\PYGZpc{}rbp),\PYGZpc{}eax
    1166:   89 c6                   mov    \PYGZpc{}eax,\PYGZpc{}esi
    1168:   48 8d 3d 99 0e 00 00    lea    0xe99(\PYGZpc{}rip),\PYGZpc{}rdi        \PYGZsh{} 2008 \PYGZlt{}\PYGZus{}IO\PYGZus{}stdin\PYGZus{}used+0x8\PYGZgt{}
    116f:   b8 00 00 00 00          mov    \PYGZdl{}0x0,\PYGZpc{}eax
    1174:   e8 b7 fe ff ff          callq  1030 \PYGZlt{}printf@plt\PYGZgt{}
    1179:   b8 00 00 00 00          mov    \PYGZdl{}0x0,\PYGZpc{}eax
    117e:   c9                      leaveq
    117f:   c3                      retq

0000000000001180 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}csu\PYGZus{}init\PYGZgt{}:
    1180:   41 57                   push   \PYGZpc{}r15
    1182:   4c 8d 3d 5f 2c 00 00    lea    0x2c5f(\PYGZpc{}rip),\PYGZpc{}r15        \PYGZsh{} 3de8 \PYGZlt{}\PYGZus{}\PYGZus{}frame\PYGZus{}dummy\PYGZus{}init\PYGZus{}array\PYGZus{}entry\PYGZgt{}
    1189:   41 56                   push   \PYGZpc{}r14
    118b:   49 89 d6                mov    \PYGZpc{}rdx,\PYGZpc{}r14
    118e:   41 55                   push   \PYGZpc{}r13
    1190:   49 89 f5                mov    \PYGZpc{}rsi,\PYGZpc{}r13
    1193:   41 54                   push   \PYGZpc{}r12
    1195:   41 89 fc                mov    \PYGZpc{}edi,\PYGZpc{}r12d
    1198:   55                      push   \PYGZpc{}rbp
    1199:   48 8d 2d 50 2c 00 00    lea    0x2c50(\PYGZpc{}rip),\PYGZpc{}rbp        \PYGZsh{} 3df0 \PYGZlt{}\PYGZus{}\PYGZus{}do\PYGZus{}global\PYGZus{}dtors\PYGZus{}aux\PYGZus{}fini\PYGZus{}array\PYGZus{}entry\PYGZgt{}
    11a0:   53                      push   \PYGZpc{}rbx
    11a1:   4c 29 fd                sub    \PYGZpc{}r15,\PYGZpc{}rbp
    11a4:   48 83 ec 08             sub    \PYGZdl{}0x8,\PYGZpc{}rsp
    11a8:   e8 53 fe ff ff          callq  1000 \PYGZlt{}\PYGZus{}init\PYGZgt{}
    11ad:   48 c1 fd 03             sar    \PYGZdl{}0x3,\PYGZpc{}rbp
    11b1:   74 1b                   je     11ce \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}csu\PYGZus{}init+0x4e\PYGZgt{}
    11b3:   31 db                   xor    \PYGZpc{}ebx,\PYGZpc{}ebx
    11b5:   0f 1f 00                nopl   (\PYGZpc{}rax)
    11b8:   4c 89 f2                mov    \PYGZpc{}r14,\PYGZpc{}rdx
    11bb:   4c 89 ee                mov    \PYGZpc{}r13,\PYGZpc{}rsi
    11be:   44 89 e7                mov    \PYGZpc{}r12d,\PYGZpc{}edi
    11c1:   41 ff 14 df             callq  *(\PYGZpc{}r15,\PYGZpc{}rbx,8)
    11c5:   48 83 c3 01             add    \PYGZdl{}0x1,\PYGZpc{}rbx
    11c9:   48 39 dd                cmp    \PYGZpc{}rbx,\PYGZpc{}rbp
    11cc:   75 ea                   jne    11b8 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}csu\PYGZus{}init+0x38\PYGZgt{}
    11ce:   48 83 c4 08             add    \PYGZdl{}0x8,\PYGZpc{}rsp
    11d2:   5b                      pop    \PYGZpc{}rbx
    11d3:   5d                      pop    \PYGZpc{}rbp
    11d4:   41 5c                   pop    \PYGZpc{}r12
    11d6:   41 5d                   pop    \PYGZpc{}r13
    11d8:   41 5e                   pop    \PYGZpc{}r14
    11da:   41 5f                   pop    \PYGZpc{}r15
    11dc:   c3                      retq
    11dd:   0f 1f 00                nopl   (\PYGZpc{}rax)

00000000000011e0 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}csu\PYGZus{}fini\PYGZgt{}:
    11e0:   c3                      retq

Desensamblado de la sección .fini:

00000000000011e4 \PYGZlt{}\PYGZus{}fini\PYGZgt{}:
    11e4:   48 83 ec 08             sub    \PYGZdl{}0x8,\PYGZpc{}rsp
    11e8:   48 83 c4 08             add    \PYGZdl{}0x8,\PYGZpc{}rsp
    11ec:   c3                      retq
\end{sphinxVerbatim}


\section{Traductores de código}
\label{\detokenize{obtencion_del_codigo:traductores-de-codigo}}
\sphinxAtStartPar
Existen dos tipos de lenguajes de programación en cuanto a la \sphinxstylestrong{forma de obtener el código máquina} o ejecutable: lenguajes \sphinxstylestrong{interpretados} y lenguajes \sphinxstylestrong{compilados}.

\sphinxAtStartPar
En los lenguajes interpretados, un programa llamado \sphinxstylestrong{intérprete} es el encargado de ir traduciendo el programa a medida que sea necesario, típicamente instrucción a instrucción, y normalmente no guardan el resultado de esa traducción.

\sphinxAtStartPar
En los lenguajes compilados, un programa llamado \sphinxstylestrong{compilador} traduce todo el programa a lenguaje máquina generando un segundo fichero con dicha traducción.

\sphinxAtStartPar
Sea interpretado o compilado \sphinxstylestrong{el programa es ejecutado por medio del sistema operativo} y, dicho código, está preparado para ser \sphinxstylestrong{ejecutado en una arquitectura de CPU} concreta (x86\sphinxhyphen{}32, x86\sphinxhyphen{}64, MIPS, ARM, etc). Este es el encargado de cargar el programa ejecutable en memoria y gestionar su ejecución por medio de una serie de algoritmos de gestión de procesos.

\sphinxAtStartPar
En el siguiente apartado te voy a explicar cómo funciona un \sphinxstylestrong{compilador}.

\begin{sphinxadmonition}{note}{Nota:}
\sphinxAtStartPar
Ejemplos de lenguajes interpretados son: \sphinxstylestrong{Python} o \sphinxstylestrong{PHP}.

\sphinxAtStartPar
Ejemplos de lenguajes compilados son: \sphinxstylestrong{C} o \sphinxstylestrong{Java}. Aunque el compilador  de \sphinxstylestrong{Java}, como veremos más adelante, genera un código máquina intermedio que será ejecutado por una máquina virtual.
\end{sphinxadmonition}


\section{Compiladores: proceso de traducción}
\label{\detokenize{obtencion_del_codigo:compiladores-proceso-de-traduccion}}
\sphinxAtStartPar
Todo comienza cuando el programador \sphinxstylestrong{escribe el código fuente}, normalmente en varios ficheros.

\sphinxAtStartPar
A continuación, se ejecuta el compilador sobre dichos ficheros generando \sphinxstylestrong{el código objeto} y dando como resultado los mismos ficheros pero con dicho código objeto. Esta traducción solo se realiza si no hay errores léxicos, sintáctico y/o semánticos en el código fuente escrito por el programador. Si hay errores en el código, el compilador avisa al programador de dichos errores.

\sphinxAtStartPar
Una vez se tienen los ficheros objeto, un programa llamado \sphinxstylestrong{linker} enlaza todos los ficheros con el código objeto y bibliotecas generando un solo fichero con el \sphinxstylestrong{código máquina o ejecutable}. El programa \sphinxstylestrong{linker} forma parte del compilador y, si no se indica lo contrario, el compilador generará el código objeto y ejecuta, a continuación, el linker automáticamente, sin que tengas que hacer nada extra.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{fases_compilador}.png}
\caption{Fases de un compilador: traducción y enlace (\sphinxstyleemphasis{linkado})}\label{\detokenize{obtencion_del_codigo:id5}}\end{figure}

\begin{sphinxadmonition}{important}{Importante:}
\sphinxAtStartPar
El compilador genera el código ejecutable para una CPU y sistema operativo concreto. Si quieres tener el programa listo para ser ejecutado en CPU MIPS, x86\sphinxhyphen{}64 y ARM, entonces tienes que compilar el programa 3 veces, para obtener el código ejecutable en cada una de estas tres arquitecturas.
\end{sphinxadmonition}


\section{Código intermedio y máquinas virtuales}
\label{\detokenize{obtencion_del_codigo:codigo-intermedio-y-maquinas-virtuales}}
\sphinxAtStartPar
Como ya se ha comentado, el código ejecutable o máquina está listo para ser ejecutado por un tipo de CPU concreta.

\sphinxAtStartPar
Hay lenguajes, como \sphinxstylestrong{Java}, para los que el compilador genera un código intermedio genérico que es ejecutado por una máquina virtual. Este código intermedio se denomina \sphinxstylestrong{bytecode}.

\sphinxAtStartPar
De esta manera no hace falta compilar el código fuente varias veces para ser ejecutado en varias CPU, se construye un código genérico ejecutable por cualquier máquina. No obstante, para poder ejecutar estos programas antes necesitas instalar la máquina virtual en tu ordenador.

\sphinxAtStartPar
Siguiendo con el ejemplo de \sphinxstylestrong{Java}, este tiene un compilador, \sphinxstylestrong{javac}, que genera código intermedio (\sphinxstylestrong{bytecode}) para ser ejecutado por la \sphinxstylestrong{Java Virtual Machine} o \sphinxstyleemphasis{JVM}.

\sphinxAtStartPar
Si quieres ejecutar en tu ordenador programas en Java, tienes que instalar el \sphinxstylestrong{JRE} (\sphinxstyleemphasis{Java Runtime Environment}). Si quieres desarrollar programas en Java, entonces necesitas instalar el \sphinxstylestrong{JDK} (\sphinxstyleemphasis{Java Development Kit}), que incluye el JRE.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.400\linewidth]{{java_bytecode}.png}
\caption{Esquema de la arquitectura general de un programa en ejecución en una JVM}\label{\detokenize{obtencion_del_codigo:id6}}\end{figure}

\sphinxAtStartPar
Por último, aquí te muestro el código fuente de un programa en Java que suma dos números y muestra el resultado por pantalla. Y, también, el \sphinxstyleemphasis{bytecode}.

\begin{sphinxuseclass}{sphinx-tabs}
\begin{sphinxuseclass}{closeable}
\sphinxAtStartPar
Código fuente en Java

\sphinxAtStartPar
Bytecode del código en Java

\end{sphinxuseclass}
\begin{sphinxuseclass}{sphinx-tabs-panel}
\begin{sphinxuseclass}{group-tab}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Main} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{p}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{,} \PYG{n}{resultado}\PYG{p}{;}

        \PYG{n}{num1} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{n}{num2} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}

        \PYG{n}{resultado} \PYG{o}{=} \PYG{n}{num1} \PYG{o}{+} \PYG{n}{num2}\PYG{p}{;}

        \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{out}\PYG{p}{.}\PYG{n+na}{println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Resultado de sumar \PYGZdq{}} \PYG{o}{+} \PYG{n}{num1} \PYG{o}{+} \PYG{l+s}{\PYGZdq{} y \PYGZdq{}} \PYG{o}{+} \PYG{n}{num2} \PYG{o}{+} \PYG{l+s}{\PYGZdq{} = \PYGZdq{}} \PYG{o}{+} \PYG{n}{resultado}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sphinx-tabs-panel}
\begin{sphinxuseclass}{group-tab}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
public class Main \PYGZob{}
    public Main();
        Code:
        0: aload\PYGZus{}0
        1: invokespecial \PYGZsh{}1                  // Method java/lang/Object.\PYGZdq{}\PYGZlt{}init\PYGZgt{}\PYGZdq{}:()V
        4: return

    public static void main(java.lang.String[]);
        Code:
        0: bipush        10
        2: istore\PYGZus{}1
        3: bipush        15
        5: istore\PYGZus{}2
        6: iload\PYGZus{}1
        7: iload\PYGZus{}2
        8: iadd
        9: istore\PYGZus{}3
        10: getstatic     \PYGZsh{}7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        13: iload\PYGZus{}1
        14: iload\PYGZus{}2
        15: iload\PYGZus{}3
        16: invokedynamic \PYGZsh{}13,  0             // InvokeDynamic \PYGZsh{}0:makeConcatWithConstants:(III)Ljava/lang/String;
        21: invokevirtual \PYGZsh{}17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        24: return
    \PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope


\chapter{Laboratorio 1: generación de código máquina}
\label{\detokenize{lab1:laboratorio-1-generacion-de-codigo-maquina}}\label{\detokenize{lab1::doc}}
\sphinxAtStartPar
En este laboratorio vas a generar el código máquina de una programa escrito en lenguaje de programación de alto nivel \sphinxcode{\sphinxupquote{C}}.

\sphinxAtStartPar
Antes, tienes que instalar el compilador de \sphinxcode{\sphinxupquote{C}} llamado \sphinxcode{\sphinxupquote{gcc}}. En los equipos del aula ya lo tienes instalado. Si usas tu portátil u ordenador y usas Windows puedes seguir los pasos que se indican en la siguiente web: \sphinxhref{https://platzi.com/tutoriales/1469-algoritmos/1901-como-instalar-gcc-para-compilar-programas-en-c-desde-la-consola-en-windows/}{instalar gcc en Windows 10}%
\begin{footnote}[2]\sphinxAtStartFootnote
\sphinxnolinkurl{https://platzi.com/tutoriales/1469-algoritmos/1901-como-instalar-gcc-para-compilar-programas-en-c-desde-la-consola-en-windows/}
%
\end{footnote}.

\sphinxAtStartPar
Una vez tengas \sphinxcode{\sphinxupquote{gcc}} instalado, sigue los pasos que se indican a continuación.


\section{Paso 1: escribir el programa}
\label{\detokenize{lab1:paso-1-escribir-el-programa}}
\sphinxAtStartPar
Copia y pega el código fuente que tienes aquí en tu editor de textos favorito y guárdalo con el nombre \sphinxcode{\sphinxupquote{main.c}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{printf} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Números del 1 al 10:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}d }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Paso 2: genera el código ensamblador}
\label{\detokenize{lab1:paso-2-genera-el-codigo-ensamblador}}
\sphinxAtStartPar
Aunque no es necesario, en este paso vas a generar el código fuente en ensamblador equivalente.

\sphinxAtStartPar
Para ello, abre una terminal, sitúate en el directorio donde tienes el fichero con el código fuente \sphinxcode{\sphinxupquote{main.c}} y ejecuta el siguiente comando:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} gcc \PYGZhy{}S main.c \PYGZhy{}o main.asm
\end{sphinxVerbatim}

\sphinxAtStartPar
Tras ejecutar dicho comando verás que hay un nuevo fichero \sphinxcode{\sphinxupquote{main.asm}} que contiene el código fuente en ensamblador.


\section{Paso 3: genera el código objeto}
\label{\detokenize{lab1:paso-3-genera-el-codigo-objeto}}
\sphinxAtStartPar
Para obtener el código objeto, usa el compilador de \sphinxcode{\sphinxupquote{C}} de la siguiente manera. Abre la terminal y situate donde está el fichero \sphinxcode{\sphinxupquote{main.c}} y ejecuta el compilador así:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} gcc \PYGZhy{}c main.c \PYGZhy{}o main.o
\end{sphinxVerbatim}


\section{Paso 4: inspeccionar el código objeto}
\label{\detokenize{lab1:paso-4-inspeccionar-el-codigo-objeto}}
\sphinxAtStartPar
El código objeto no se puede visualizar. Intenta abrir el fichero \sphinxcode{\sphinxupquote{main.o}} para comprobar que no se puede ver nada, no es inteligible para el ser humano.

\sphinxAtStartPar
No obstante se puede desensamblar para inspeccionar el código objeto en hexadecimal. Abre la terminal y sitúate en el directorio donde está el fichero \sphinxcode{\sphinxupquote{main.o}} y ejecuta la siguiente orden:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} objdump \PYGZhy{}d main.o \PYGZgt{} main.o.hex
\end{sphinxVerbatim}

\sphinxAtStartPar
Este comando genera una representación en hexadecimal, con sus respectivos mnemotécnicos en ensamblador, y lo guarda en el fichero \sphinxcode{\sphinxupquote{main.o.hex}}. Ábrelo para verlo.


\section{Paso 5: generar el código máquina ejecutable}
\label{\detokenize{lab1:paso-5-generar-el-codigo-maquina-ejecutable}}
\sphinxAtStartPar
El código objeto \sphinxcode{\sphinxupquote{main.o}} no se puede ejecutar, porque falta enlazarlo con bibliotecas del lenguaje \sphinxcode{\sphinxupquote{C}}, entre otras cosas.

\sphinxAtStartPar
Para poder ejecutar el programa que escribiste en el Paso 1 usando el lenguaje de programación \sphinxcode{\sphinxupquote{C}}, tienes que compilar de la siguiente forma:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} gcc main.c \PYGZhy{}o main
\end{sphinxVerbatim}

\sphinxAtStartPar
Como siempre, antes de ejecutar ese comando tienes que situarte en el directorio donde está el fichero \sphinxcode{\sphinxupquote{main.c}}. Verás que se generará un fichero, con el código máquina ejecutable, llamado \sphinxcode{\sphinxupquote{main}}.


\section{Paso 6: ejecuta el programa}
\label{\detokenize{lab1:paso-6-ejecuta-el-programa}}
\sphinxAtStartPar
Tienes que ejecutar el código máquina ejecutable que tienes en el fichero \sphinxcode{\sphinxupquote{main}}. Abre la termina, sitúate en el directorio donde está el programa (fichero \sphinxcode{\sphinxupquote{main}}) y ejecútalo tal que así:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ./main
\end{sphinxVerbatim}

\sphinxAtStartPar
Verás que muestra los primeros 10 números.


\section{Entrega}
\label{\detokenize{lab1:entrega}}
\sphinxAtStartPar
Hazme entrega de los siguientes ficheros:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{main.c}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{main.asm}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{main.o}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{main.o.hex}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{main}}

\end{itemize}


\section{Criterios de evaluación}
\label{\detokenize{lab1:criterios-de-evaluacion}}
\sphinxAtStartPar
En esta práctica se aplica el \sphinxcode{\sphinxupquote{Resultado de Aprendizaje 1: reconoce los elementos y herramientas que intervienen en el desarrollo de un programa informático, analizando sus características y las fases en las que actúan hasta llegar a su puesta en funcionamiento.}}. Y en concreto los siguientes criterios de evaluación:
\begin{itemize}
\item {} \begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Se han diferenciado los conceptos de código fuente, código objeto y código ejecutable. (20\%)

\end{enumerate}

\item {} \begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Se han reconocido las características de la generación de código intermedio para su ejecución en máquinas virtuales. (10\%)

\end{enumerate}

\end{itemize}

\sphinxstepscope


\chapter{Laboratorio 2: generación de bytecode}
\label{\detokenize{lab2:laboratorio-2-generacion-de-bytecode}}\label{\detokenize{lab2::doc}}
\sphinxAtStartPar
En este laboratorio vas a generar el código intermedio bytecode de Java desensamblado, para poder visualizar, qué aspecto tiene dicho código intermedio.

\sphinxAtStartPar
Antes, tienes que instalar el \sphinxcode{\sphinxupquote{JDK}}. En los equipos del aula ya está instalado, así que solo lo tienes que hacer en tu ordenador o portátil siempre que este \sphinxstyleemphasis{lab} lo vayas a realizar desde tu equipo personal.


\section{Paso 1: escribir el programa}
\label{\detokenize{lab2:paso-1-escribir-el-programa}}
\sphinxAtStartPar
Copia y pega el código fuente en Java que tienes aquí en tu editor de textos favorito y guárdalo con el nombre \sphinxcode{\sphinxupquote{Main.java}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Main} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{p}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{out}\PYG{p}{.}\PYG{n+na}{println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Números del 1 al 10:\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{out}\PYG{p}{.}\PYG{n+na}{print}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{out}\PYG{p}{.}\PYG{n+na}{println}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Paso 2: compilar programa en Java}
\label{\detokenize{lab2:paso-2-compilar-programa-en-java}}
\sphinxAtStartPar
Cuando tenemos un programa en Java en un simple fichero, compilar dicho programa es muy sencillo (sin ayuda de IDEs ni herramientas gráficas).

\sphinxAtStartPar
Tan solo tienes que abrir una terminal, situarte donde está el fichero \sphinxcode{\sphinxupquote{Main.java}} y ejecutar el compilador de Java \sphinxstyleliteralstrong{\sphinxupquote{javac}} tal que así:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} javac Main.java
\end{sphinxVerbatim}

\sphinxAtStartPar
Tras ejecutar este comando verás que se ha generado un fichero con el mismo nombre pero con extensión \sphinxcode{\sphinxupquote{.class}}, en este ejemplo \sphinxcode{\sphinxupquote{Main.class}}, que contiene el \sphinxstyleemphasis{bytecode} de Java ejecutable por la \sphinxcode{\sphinxupquote{JVM}} o Máquina Virtual de Java.

\sphinxAtStartPar
Si intentas abrir este \sphinxcode{\sphinxupquote{.class}} con un editor verás una serie de símbolos sin sentido. Recuerda que el código objeto es ininteligible para el ser humano.


\section{Paso 3: análisis del bytecode}
\label{\detokenize{lab2:paso-3-analisis-del-bytecode}}
\sphinxAtStartPar
Cuando no dispones de los ficheros con el código fuente en Java, puedes usar la herramienta \sphinxcode{\sphinxupquote{javap}} para desensamblar un fichero \sphinxcode{\sphinxupquote{.class}} tal que así:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} javap \PYGZhy{}c Main.class \PYGZgt{} Main.dis
\end{sphinxVerbatim}

\sphinxAtStartPar
Tras ejecutar dicho comando verás el código desensamblado en el fichero llamado \sphinxcode{\sphinxupquote{Main.dis}}. Ábrelo con tu editor de textos favorito y observa el resultado.


\section{Paso 4: visualizar el código máquina}
\label{\detokenize{lab2:paso-4-visualizar-el-codigo-maquina}}
\sphinxAtStartPar
Para poder echar un vistazo al código máquina, en formato hexadecimal, de un programa compilado en Java, debes usar el siguiente comando:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} java \PYGZhy{}XX:+UnlockDiagnosticVMOptions \PYGZhy{}XX:+PrintAssembly Main \PYGZgt{} Main.asm
\end{sphinxVerbatim}

\sphinxAtStartPar
Donde:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{java}: se trata del comando que llama a la máquina virtual de Java para ejecutar un programa.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{}XX:+UnlockDiagnosticVMOptions}: es una opción necesaria para ver el código máquina.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{}XX:+PrintAssembly}: es para que te muestre el código ensamblador en hexadecimal.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Main}: es el nombre del programa (coincide con el nombre de la clase a ejecutar).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Main.asm}: nombre del fichero donde escribe el resultado.

\end{itemize}

\sphinxAtStartPar
Este comando escribe el contenido en un fichero llamado \sphinxcode{\sphinxupquote{Main.asm}}. Ábrelo con tu editor de textos favorito y observa el resultado.


\section{Entrega}
\label{\detokenize{lab2:entrega}}
\sphinxAtStartPar
Hazme entrega de los siguientes ficheros:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Main.java}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Main.class}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Main.dis}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Main.asm}}

\end{itemize}


\section{Criterios de evaluación}
\label{\detokenize{lab2:criterios-de-evaluacion}}
\sphinxAtStartPar
En esta práctica se aplica el \sphinxcode{\sphinxupquote{Resultado de Aprendizaje 1: reconoce los elementos y herramientas que intervienen en el desarrollo de un programa informático, analizando sus características y las fases en las que actúan hasta llegar a su puesta en funcionamiento.}}. Y en concreto los siguientes criterios de evaluación:
\begin{itemize}
\item {} \begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Se han diferenciado los conceptos de código fuente, código objeto y código ejecutable. (20\%)

\end{enumerate}

\item {} \begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Se han reconocido las características de la generación de código intermedio para su ejecución en máquinas virtuales. (10\%)

\end{enumerate}

\end{itemize}



\renewcommand{\indexname}{Índice}
\footnotesize\raggedright\printindex
\end{document}